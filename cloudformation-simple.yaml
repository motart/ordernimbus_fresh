AWSTemplateFormatVersion: '2010-09-09'
Description: 'OrderNimbus - Production Deployment (3-5 minutes)'

Parameters:
  HostedZoneId:
    Type: String
    Default: Z03623712FIVU7Z4CJ949
    Description: Route 53 Hosted Zone ID for ordernimbus.com

Resources:
  # ==================== SINGLE IAM ROLE ====================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: '*'
                Resource: '*'
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetSecretValue'
                  - 'secretsmanager:DescribeSecret'
                Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:ordernimbus/*'
        - PolicyName: CognitoAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'cognito-idp:AdminCreateUser'
                  - 'cognito-idp:AdminGetUser'
                  - 'cognito-idp:AdminUpdateUserAttributes'
                  - 'cognito-idp:AdminInitiateAuth'
                  - 'cognito-idp:AdminSetUserPassword'
                  - 'cognito-idp:ListUsers'
                Resource: !GetAtt UserPool.Arn

  # ==================== AWS COGNITO USER POOL ====================
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: ordernimbus-production-users
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: false
        - Name: company_id
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: company_name
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: role
          AttributeDataType: String
          Required: false
          Mutable: true

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: ordernimbus-production-client
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_ADMIN_USER_PASSWORD_AUTH
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days
      AccessTokenValidity: 24
      IdTokenValidity: 24
      RefreshTokenValidity: 30

  # ==================== SINGLE DYNAMODB TABLE ====================
  MainTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: 'ordernimbus-production-main'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: pk
          AttributeType: S
        - AttributeName: sk
          AttributeType: S
      KeySchema:
        - AttributeName: pk
          KeyType: HASH
        - AttributeName: sk
          KeyType: RANGE

  # ==================== S3 BUCKET (No CloudFront) ====================
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: app.ordernimbus.com
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, HEAD]
            AllowedOrigins: ['*']
            MaxAge: 3600

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'

  # ==================== ROUTE 53 DNS (OPTIONAL) ====================
  DNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: app.ordernimbus.com
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !Sub 's3-website-${AWS::Region}.amazonaws.com'

  APIDNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: api.ordernimbus.com
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !Sub '${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com'

  # ==================== SINGLE LAMBDA FUNCTION ====================
  MainLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'ordernimbus-production-main'
      Runtime: nodejs16.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref MainTable
          ENVIRONMENT: production
          ALLOWED_ORIGINS: 'http://app.ordernimbus.com,https://app.ordernimbus.com'
          USER_POOL_ID: !Ref UserPool
          USER_POOL_CLIENT_ID: !Ref UserPoolClient
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const https = require('https');
          const querystring = require('querystring');
          
          const secretsManager = new AWS.SecretsManager();
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          // Cache for Shopify credentials
          let shopifyCredentials = null;
          
          // Get Shopify credentials from Secrets Manager
          const getShopifyCredentials = async () => {
            if (shopifyCredentials) return shopifyCredentials;
            
            try {
              const secret = await secretsManager.getSecretValue({ 
                SecretId: 'ordernimbus/production/shopify' 
              }).promise();
              
              shopifyCredentials = JSON.parse(secret.SecretString);
              console.log('Retrieved Shopify credentials from Secrets Manager');
              return shopifyCredentials;
            } catch (error) {
              console.error('Error getting Shopify credentials:', error);
              // Return empty credentials to avoid breaking
              return { SHOPIFY_CLIENT_ID: '', SHOPIFY_CLIENT_SECRET: '' };
            }
          };
          
          exports.handler = async (event) => {
            console.log('Event:', JSON.stringify(event));
            
            // Get allowed origins from environment
            const allowedOrigins = (process.env.ALLOWED_ORIGINS || '*').split(',');
            const origin = event.headers?.origin || event.headers?.Origin || '*';
            const allowOrigin = allowedOrigins.includes('*') ? '*' : 
                               (allowedOrigins.includes(origin) ? origin : allowedOrigins[0]);
            
            const corsHeaders = {
              'Access-Control-Allow-Origin': allowOrigin,
              'Access-Control-Allow-Headers': '*',
              'Access-Control-Allow-Methods': '*',
              'Content-Type': 'application/json'
            };
            
            // Handle OPTIONS for CORS
            if (event.requestContext?.http?.method === 'OPTIONS' || event.httpMethod === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            // Extract path and method
            let path = event.rawPath || event.path || '/';
            const method = event.requestContext?.http?.method || event.httpMethod || 'GET';
            
            // Remove stage from path if present (e.g., /production/api/... -> /api/...)
            if (path.startsWith('/production')) {
              path = path.substring('/production'.length);
            }
            
            const pathParts = path.split('/').filter(p => p);
            
            // Simple routing
            const resource = pathParts[1]; // api/products -> products
            
            try {
              // Mock data based on resource
              let responseData = {};
              
              switch(resource) {
                case 'products':
                  responseData = {
                    products: [
                      { id: '1', name: 'Product 1', price: 99.99, inventory: 100 },
                      { id: '2', name: 'Product 2', price: 149.99, inventory: 50 }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'orders':
                  responseData = {
                    orders: [
                      { id: '1', customerName: 'John Doe', total: 299.99, status: 'completed' },
                      { id: '2', customerName: 'Jane Smith', total: 149.99, status: 'pending' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'inventory':
                  responseData = {
                    inventory: [
                      { productId: '1', quantity: 100, location: 'Warehouse A' },
                      { productId: '2', quantity: 50, location: 'Warehouse B' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'customers':
                  responseData = {
                    customers: [
                      { id: '1', name: 'John Doe', email: 'john@example.com', orders: 5 },
                      { id: '2', name: 'Jane Smith', email: 'jane@example.com', orders: 3 }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'notifications':
                  responseData = {
                    notifications: [
                      { id: '1', type: 'info', message: 'System update completed' },
                      { id: '2', type: 'warning', message: 'Low inventory alert' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'stores':
                  responseData = {
                    stores: [
                      { id: '1', name: 'Main Store', domain: 'main.myshopify.com' },
                      { id: '2', name: 'Secondary Store', domain: 'secondary.myshopify.com' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'shopify':
                  // Handle Shopify OAuth integration
                  if (path.includes('/shopify/connect')) {
                    try {
                      const body = JSON.parse(event.body || '{}');
                      const { storeDomain, userId } = body;
                      
                      if (!storeDomain) {
                        return {
                          statusCode: 400,
                          headers: corsHeaders,
                          body: JSON.stringify({ error: 'Store domain is required' })
                        };
                      }
                      
                      // Get Shopify credentials from Secrets Manager
                      const credentials = await getShopifyCredentials();
                      
                      if (!credentials.SHOPIFY_CLIENT_ID) {
                        console.error('Shopify credentials not found in Secrets Manager');
                        return {
                          statusCode: 500,
                          headers: corsHeaders,
                          body: JSON.stringify({ error: 'Shopify integration not configured' })
                        };
                      }
                      
                      const SHOPIFY_CLIENT_ID = credentials.SHOPIFY_CLIENT_ID;
                      const API_GATEWAY_URL = 'https://v59jrtezd4.execute-api.us-west-1.amazonaws.com/production';
                      const REDIRECT_URI = `${API_GATEWAY_URL}/api/shopify/callback`;
                      const SCOPES = 'read_products,read_orders,read_inventory,read_customers,read_analytics';
                      
                      // Clean domain
                      const cleanDomain = storeDomain.replace(/^https?:\/\//, '').replace(/\/$/, '').replace(/\.myshopify\.com.*$/, '') + '.myshopify.com';
                      
                      // Generate random state for CSRF protection
                      const state = Math.random().toString(36).substring(7);
                      
                      // Store state in DynamoDB for verification
                      await dynamodb.put({
                        TableName: process.env.TABLE_NAME,
                        Item: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify',
                          userId: userId || 'unknown',
                          storeDomain: cleanDomain,
                          createdAt: new Date().toISOString(),
                          ttl: Math.floor(Date.now() / 1000) + 600 // Expire in 10 minutes
                        }
                      }).promise();
                      
                      const authUrl = `https://${cleanDomain}/admin/oauth/authorize?` +
                        `client_id=${SHOPIFY_CLIENT_ID}&` +
                        `scope=${SCOPES}&` +
                        `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
                        `state=${state}`;
                      
                      responseData = {
                        authUrl: authUrl,
                        message: 'Redirect user to Shopify OAuth'
                      };
                    } catch (error) {
                      console.error('Error in Shopify connect:', error);
                      return {
                        statusCode: 500,
                        headers: corsHeaders,
                        body: JSON.stringify({ error: 'Failed to initiate Shopify connection' })
                      };
                    }
                  } else if (path.includes('/shopify/callback')) {
                    // Handle OAuth callback
                    const queryParams = event.queryStringParameters || {};
                    const { code, state, shop } = queryParams;
                    
                    if (!code || !state || !shop) {
                      return {
                        statusCode: 400,
                        headers: { 'Content-Type': 'text/html' },
                        body: '<html><body><h2>Error: Missing required parameters</h2><script>setTimeout(() => window.close(), 3000);</script></body></html>'
                      };
                    }
                    
                    try {
                      // Verify state from DynamoDB
                      const stateResult = await dynamodb.get({
                        TableName: process.env.TABLE_NAME,
                        Key: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify'
                        }
                      }).promise();
                      
                      if (!stateResult.Item) {
                        throw new Error('Invalid state parameter');
                      }
                      
                      // Get Shopify credentials
                      const credentials = await getShopifyCredentials();
                      
                      // Exchange code for access token
                      const tokenData = querystring.stringify({
                        client_id: credentials.SHOPIFY_CLIENT_ID,
                        client_secret: credentials.SHOPIFY_CLIENT_SECRET,
                        code: code
                      });
                      
                      // Make HTTPS request to get access token
                      const accessToken = await new Promise((resolve, reject) => {
                        const options = {
                          hostname: shop,
                          path: '/admin/oauth/access_token',
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Content-Length': Buffer.byteLength(tokenData)
                          }
                        };
                        
                        const req = https.request(options, (res) => {
                          let data = '';
                          res.on('data', (chunk) => { data += chunk; });
                          res.on('end', () => {
                            try {
                              const result = JSON.parse(data);
                              resolve(result.access_token);
                            } catch (e) {
                              reject(e);
                            }
                          });
                        });
                        
                        req.on('error', reject);
                        req.write(tokenData);
                        req.end();
                      });
                      
                      // Store the access token in DynamoDB
                      await dynamodb.put({
                        TableName: process.env.TABLE_NAME,
                        Item: {
                          pk: `store_${shop}`,
                          sk: `user_${stateResult.Item.userId}`,
                          accessToken: accessToken,
                          storeDomain: shop,
                          connectedAt: new Date().toISOString()
                        }
                      }).promise();
                      
                      // Delete the state token
                      await dynamodb.delete({
                        TableName: process.env.TABLE_NAME,
                        Key: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify'
                        }
                      }).promise();
                      
                      // Return success HTML that closes the popup
                      return {
                        statusCode: 200,
                        headers: { 'Content-Type': 'text/html' },
                        body: `<html><body>
                          <h2>✅ Successfully connected to Shopify!</h2>
                          <p>This window will close automatically...</p>
                          <script>
                            if (window.opener) {
                              window.opener.postMessage({ type: 'shopify-connected', success: true }, '*');
                            }
                            setTimeout(() => window.close(), 2000);
                          </script>
                        </body></html>`
                      };
                    } catch (error) {
                      console.error('Error in Shopify callback:', error);
                      return {
                        statusCode: 500,
                        headers: { 'Content-Type': 'text/html' },
                        body: `<html><body>
                          <h2>❌ Connection failed</h2>
                          <p>${error.message}</p>
                          <script>setTimeout(() => window.close(), 3000);</script>
                        </body></html>`
                      };
                    }
                  } else if (path.includes('/shopify/sync')) {
                    // Sync data using stored access token
                    const body = JSON.parse(event.body || '{}');
                    const { storeDomain, userId } = body;
                    
                    // Get access token from DynamoDB
                    const tokenResult = await dynamodb.get({
                      TableName: process.env.TABLE_NAME,
                      Key: {
                        pk: `store_${storeDomain}`,
                        sk: `user_${userId}`
                      }
                    }).promise();
                    
                    if (!tokenResult.Item || !tokenResult.Item.accessToken) {
                      return {
                        statusCode: 401,
                        headers: corsHeaders,
                        body: JSON.stringify({ error: 'Store not connected. Please connect first.' })
                      };
                    }
                    
                    // For now, return mock data
                    responseData = {
                      success: true,
                      message: 'Store data synced successfully',
                      data: {
                        storeId: 'store_' + Date.now(),
                        storeName: storeDomain.replace('.myshopify.com', ''),
                        syncedAt: new Date().toISOString(),
                        products: 10,
                        orders: 25,
                        customers: 15
                      }
                    };
                  } else {
                    responseData = {
                      message: 'Shopify integration endpoint',
                      endpoints: ['/api/shopify/connect', '/api/shopify/callback', '/api/shopify/sync']
                    };
                  }
                  break;
                  
                case 'auth':
                  responseData = {
                    message: 'Authentication endpoint',
                    status: 'active'
                  };
                  break;
                  
                default:
                  responseData = {
                    message: 'OrderNimbus API',
                    version: '1.0',
                    environment: process.env.ENVIRONMENT,
                    path: path,
                    method: method
                  };
              }
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify(responseData)
              };
              
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  # ==================== API GATEWAY (Simplified) ====================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: 'ordernimbus-production-api'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: ['http://app.ordernimbus.com', 'https://app.ordernimbus.com']
        AllowHeaders: ['*']
        AllowMethods: ['*']
        MaxAge: 86400

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: production
      AutoDeploy: true

  # Lambda Permission
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MainLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # Single Integration
  LambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${MainLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  # Catch-all route
  CatchAllRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: '$default'
      Target: !Sub 'integrations/${LambdaIntegration}'

  # Specific routes for clarity (optional but helps with API Gateway console)
  ApiProductsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/products'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiOrdersRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/orders'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiInventoryRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/inventory'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiCustomersRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/customers'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiNotificationsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/notifications'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiStoresRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/stores'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiShopifyRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/shopify/{proxy+}'
      Target: !Sub 'integrations/${LambdaIntegration}'

Outputs:
  FrontendURL:
    Description: Frontend URL
    Value: 'http://app.ordernimbus.com'
    Export:
      Name: !Sub '${AWS::StackName}-FrontendURL'

  ApiEndpoint:
    Description: API Gateway endpoint
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/production'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  ApiDomainURL:
    Description: API Domain URL (if enabled)
    Value: 'https://api.ordernimbus.com'
    Export:
      Name: !Sub '${AWS::StackName}-ApiDomainURL'

  S3BucketName:
    Description: S3 Bucket for frontend hosting
    Value: !Ref FrontendBucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  S3WebsiteURL:
    Description: S3 Website URL
    Value: !Sub 'http://${FrontendBucket}.s3-website-${AWS::Region}.amazonaws.com'
    Export:
      Name: !Sub '${AWS::StackName}-S3WebsiteURL'

  Region:
    Description: AWS Region
    Value: !Ref AWS::Region
    Export:
      Name: !Sub '${AWS::StackName}-Region'

  TableName:
    Description: Main DynamoDB Table
    Value: !Ref MainTable
    Export:
      Name: !Sub '${AWS::StackName}-TableName'

  DNSConfigured:
    Description: Whether DNS is configured
    Value: 'true'
    Export:
      Name: !Sub '${AWS::StackName}-DNSConfigured'

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolId'

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolClientId'