AWSTemplateFormatVersion: '2010-09-09'
Description: 'OrderNimbus - Production Deployment (3-5 minutes)'

Parameters:
  HostedZoneId:
    Type: String
    Default: Z03623712FIVU7Z4CJ949
    Description: Route 53 Hosted Zone ID for ordernimbus.com
  
  CertificateArn:
    Type: String
    Default: ''
    Description: ACM Certificate ARN for app.ordernimbus.com (must be in us-east-1 for CloudFront)
  
  EnableCloudFront:
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Enable CloudFront distribution (requires certificate in us-east-1)
  
  LambdaCodeBucket:
    Type: String
    Default: 'ordernimbus-lambda-code'
    Description: S3 bucket containing Lambda function code

Conditions:
  CreateApiDNS: !Not [!Equals [!Ref HostedZoneId, '']]
  CreateCloudFront: !And
    - !Equals [!Ref EnableCloudFront, 'true']
    - !Not [!Equals [!Ref CertificateArn, '']]

Resources:
  # ==================== SINGLE IAM ROLE ====================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:BatchWriteItem'
                Resource: 
                  - !GetAtt MainTable.Arn
                  - !Sub '${MainTable.Arn}/index/*'
                  - !GetAtt SubscriptionTable.Arn
                  - !Sub '${SubscriptionTable.Arn}/index/*'
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetSecretValue'
                  - 'secretsmanager:DescribeSecret'
                Resource: !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:ordernimbus/*'
        - PolicyName: SSMParameterAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'ssm:GetParameter'
                  - 'ssm:GetParameters'
                  - 'ssm:GetParametersByPath'
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/ordernimbus/*'
        - PolicyName: CognitoAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'cognito-idp:AdminCreateUser'
                  - 'cognito-idp:AdminGetUser'
                  - 'cognito-idp:AdminUpdateUserAttributes'
                  - 'cognito-idp:AdminInitiateAuth'
                  - 'cognito-idp:AdminSetUserPassword'
                  - 'cognito-idp:ListUsers'
                  - 'cognito-idp:ForgotPassword'
                Resource: !GetAtt UserPool.Arn

  # ==================== AWS COGNITO USER POOL ====================
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: ordernimbus-production-users
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: false
        - Name: company_id
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: company_name
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: role
          AttributeDataType: String
          Required: false
          Mutable: true

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: ordernimbus-production-client
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_ADMIN_USER_PASSWORD_AUTH
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days
      AccessTokenValidity: 24
      IdTokenValidity: 24
      RefreshTokenValidity: 30

  # ==================== DYNAMODB TABLES ====================
  MainTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: 'ordernimbus-production-main'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: pk
          AttributeType: S
        - AttributeName: sk
          AttributeType: S
      KeySchema:
        - AttributeName: pk
          KeyType: HASH
        - AttributeName: sk
          KeyType: RANGE
  
  # Subscription Management Table
  SubscriptionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: 'ordernimbus-production-subscriptions'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: subscriptionId
          AttributeType: S
        - AttributeName: status
          AttributeType: S
        - AttributeName: planId
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: subscriptionId
          KeyType: RANGE
      GlobalSecondaryIndexes:
        - IndexName: StatusIndex
          KeySchema:
            - AttributeName: status
              KeyType: HASH
            - AttributeName: userId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: PlanIndex
          KeySchema:
            - AttributeName: planId
              KeyType: HASH
            - AttributeName: userId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL

  # ==================== S3 BUCKET ====================
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'ordernimbus-production-frontend-${AWS::AccountId}'
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: !If [CreateCloudFront, true, false]
        BlockPublicPolicy: !If [CreateCloudFront, true, false]
        IgnorePublicAcls: !If [CreateCloudFront, true, false]
        RestrictPublicBuckets: !If [CreateCloudFront, true, false]
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, HEAD]
            AllowedOrigins: 
              - 'https://app.ordernimbus.com'
              - 'http://localhost:3000'
            MaxAge: 3600

  # CloudFront Origin Access Identity for secure S3 access
  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Condition: CreateCloudFront
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'OAI for ${AWS::StackName}'

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontAccess
            Effect: Allow
            Principal:
              AWS: !If 
                - CreateCloudFront
                - !Sub 'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${CloudFrontOriginAccessIdentity}'
                - '*'
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'
            Condition:
              Bool:
                'aws:SecureTransport': 'false'

  # ==================== SSL CERTIFICATE ====================
  # Note: Certificate must be in us-east-1 for CloudFront
  # If deploying to us-west-1, you'll need to manually create a certificate in us-east-1
  # and provide its ARN as a parameter, or use a Custom Resource to create it
  
  # For now, we'll assume the certificate exists or create it conditionally
  # You can manually create the certificate using:
  # aws acm request-certificate --domain-name app.ordernimbus.com --validation-method DNS --region us-east-1

  # ==================== CLOUDFRONT DISTRIBUTION ====================
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Condition: CreateCloudFront
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub 'OrderNimbus Production - ${AWS::StackName}'
        DefaultRootObject: index.html
        HttpVersion: http2
        
        # Custom domain
        Aliases:
          - app.ordernimbus.com
        
        # SSL Certificate
        ViewerCertificate:
          AcmCertificateArn: !Ref CertificateArn
          MinimumProtocolVersion: TLSv1.2_2021
          SslSupportMethod: sni-only
        
        # S3 Origin with OAI
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}'
        
        # Default Cache Behavior
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          MinTTL: 0
          DefaultTTL: 86400
          MaxTTL: 31536000
        
        # Custom Error Pages for SPA
        CustomErrorResponses:
          - ErrorCachingMinTTL: 0
            ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCachingMinTTL: 0
            ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
        
        # Price Class
        PriceClass: PriceClass_100
        
        # Logging (optional)
        # Logging:
        #   Bucket: !Sub '${LoggingBucket}.s3.amazonaws.com'
        #   Prefix: cloudfront/
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-cloudfront'

  # ==================== ROUTE 53 DNS ====================
  # DNS record for app.ordernimbus.com pointing to CloudFront
  AppDNSRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateCloudFront
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: app.ordernimbus.com
      Type: A
      AliasTarget:
        DNSName: !GetAtt CloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2  # CloudFront's hosted zone ID (fixed value)
        EvaluateTargetHealth: false
  
  # DNS record for api.ordernimbus.com pointing to API Gateway
  ApiDNSRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateApiDNS
    Properties:
      HostedZoneId: !Ref HostedZoneId
      Name: api.ordernimbus.com
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !Sub '${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com'

  # ==================== SINGLE LAMBDA FUNCTION ====================
  MainLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'ordernimbus-production-main'
      Runtime: nodejs16.x  # Use Node 16 which includes aws-sdk v2
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref MainTable
          ENVIRONMENT: production
          USER_POOL_ID: !Ref UserPool
          USER_POOL_CLIENT_ID: !Ref UserPoolClient
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const https = require('https');
          const querystring = require('querystring');
          
          const secretsManager = new AWS.SecretsManager();
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          // Cache for Shopify credentials
          let shopifyCredentials = null;
          
          // Get Shopify credentials from Secrets Manager
          const getShopifyCredentials = async () => {
            if (shopifyCredentials) return shopifyCredentials;
            
            try {
              const secret = await secretsManager.getSecretValue({ 
                SecretId: 'ordernimbus/production/shopify' 
              }).promise();
              
              shopifyCredentials = JSON.parse(secret.SecretString);
              console.log('Retrieved Shopify credentials from Secrets Manager');
              return shopifyCredentials;
            } catch (error) {
              console.error('Error getting Shopify credentials:', error);
              // Return empty credentials to avoid breaking
              return { SHOPIFY_CLIENT_ID: '', SHOPIFY_CLIENT_SECRET: '' };
            }
          };
          
          exports.handler = async (event) => {
            console.log('Event:', JSON.stringify(event));
            
            // Get origin from request headers
            const origin = event.headers?.origin || event.headers?.Origin || 'http://app.ordernimbus.com';
            
            // List of allowed origins
            const allowedOrigins = [
              'http://app.ordernimbus.com',
              'https://app.ordernimbus.com',
              'http://localhost:3000',
              'http://127.0.0.1:3000',
              'http://app.ordernimbus.com.s3-website-us-west-1.amazonaws.com',
              'http://app.ordernimbus.com.s3-website-us-east-1.amazonaws.com'
            ];
            
            // Check if origin is allowed
            const allowOrigin = allowedOrigins.includes(origin) ? origin : allowedOrigins[0];
            
            const corsHeaders = {
              'Access-Control-Allow-Origin': allowOrigin,
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS,HEAD,PATCH',
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Max-Age': '86400',
              'Content-Type': 'application/json'
            };
            
            // Handle OPTIONS for CORS preflight
            if (event.requestContext?.http?.method === 'OPTIONS' || event.httpMethod === 'OPTIONS') {
              console.log('Handling OPTIONS request for CORS');
              return { 
                statusCode: 200, 
                headers: corsHeaders, 
                body: JSON.stringify({ message: 'CORS preflight successful' }) 
              };
            }
            
            // Extract path and method
            let path = event.rawPath || event.path || '/';
            const method = event.requestContext?.http?.method || event.httpMethod || 'GET';
            
            // Remove stage from path if present (e.g., /production/api/... -> /api/...)
            if (path.startsWith('/production')) {
              path = path.substring('/production'.length);
            }
            
            const pathParts = path.split('/').filter(p => p);
            
            // Simple routing
            const resource = pathParts[1]; // api/products -> products
            
            try {
              // Mock data based on resource
              let responseData = {};
              
              switch(resource) {
                case 'products':
                  responseData = {
                    products: [
                      { id: '1', name: 'Product 1', price: 99.99, inventory: 100 },
                      { id: '2', name: 'Product 2', price: 149.99, inventory: 50 }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'orders':
                  responseData = {
                    orders: [
                      { id: '1', customerName: 'John Doe', total: 299.99, status: 'completed' },
                      { id: '2', customerName: 'Jane Smith', total: 149.99, status: 'pending' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'inventory':
                  responseData = {
                    inventory: [
                      { productId: '1', quantity: 100, location: 'Warehouse A' },
                      { productId: '2', quantity: 50, location: 'Warehouse B' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'customers':
                  responseData = {
                    customers: [
                      { id: '1', name: 'John Doe', email: 'john@example.com', orders: 5 },
                      { id: '2', name: 'Jane Smith', email: 'jane@example.com', orders: 3 }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'notifications':
                  responseData = {
                    notifications: [
                      { id: '1', type: 'info', message: 'System update completed' },
                      { id: '2', type: 'warning', message: 'Low inventory alert' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'config':
                  // Return application configuration
                  responseData = {
                    environment: process.env.ENVIRONMENT || 'production',
                    apiUrl: `https://${event.requestContext?.domainName || event.headers?.host}/${event.requestContext?.stage || 'production'}`,
                    region: process.env.AWS_REGION || 'us-west-1',
                    userPoolId: process.env.USER_POOL_ID,
                    clientId: process.env.USER_POOL_CLIENT_ID,
                    features: {
                      enableDebug: false,
                      enableAnalytics: true,
                      enableMockData: false,
                      useWebCrypto: true
                    }
                  };
                  break;
                  
                case 'stores':
                  responseData = {
                    stores: [
                      { id: '1', name: 'Main Store', domain: 'main.myshopify.com' },
                      { id: '2', name: 'Secondary Store', domain: 'secondary.myshopify.com' }
                    ],
                    count: 2
                  };
                  break;
                  
                case 'shopify':
                  // Handle Shopify OAuth integration
                  if (path.includes('/shopify/connect')) {
                    try {
                      const body = JSON.parse(event.body || '{}');
                      const { storeDomain, userId } = body;
                      
                      if (!storeDomain) {
                        return {
                          statusCode: 400,
                          headers: corsHeaders,
                          body: JSON.stringify({ error: 'Store domain is required' })
                        };
                      }
                      
                      // Get Shopify credentials from Secrets Manager
                      const credentials = await getShopifyCredentials();
                      
                      if (!credentials.SHOPIFY_CLIENT_ID) {
                        console.error('Shopify credentials not found in Secrets Manager');
                        return {
                          statusCode: 500,
                          headers: corsHeaders,
                          body: JSON.stringify({ error: 'Shopify integration not configured' })
                        };
                      }
                      
                      const SHOPIFY_CLIENT_ID = credentials.SHOPIFY_CLIENT_ID;
                      const API_GATEWAY_URL = 'https://v59jrtezd4.execute-api.us-west-1.amazonaws.com/production';
                      const REDIRECT_URI = `${API_GATEWAY_URL}/api/shopify/callback`;
                      const SCOPES = 'read_products,read_orders,read_inventory,read_customers,read_analytics';
                      
                      // Clean domain
                      const cleanDomain = storeDomain.replace(/^https?:\/\//, '').replace(/\/$/, '').replace(/\.myshopify\.com.*$/, '') + '.myshopify.com';
                      
                      // Generate random state for CSRF protection
                      const state = Math.random().toString(36).substring(7);
                      
                      // Store state in DynamoDB for verification
                      await dynamodb.put({
                        TableName: process.env.TABLE_NAME,
                        Item: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify',
                          userId: userId || 'unknown',
                          storeDomain: cleanDomain,
                          createdAt: new Date().toISOString(),
                          ttl: Math.floor(Date.now() / 1000) + 600 // Expire in 10 minutes
                        }
                      }).promise();
                      
                      const authUrl = `https://${cleanDomain}/admin/oauth/authorize?` +
                        `client_id=${SHOPIFY_CLIENT_ID}&` +
                        `scope=${SCOPES}&` +
                        `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
                        `state=${state}`;
                      
                      responseData = {
                        authUrl: authUrl,
                        message: 'Redirect user to Shopify OAuth'
                      };
                    } catch (error) {
                      console.error('Error in Shopify connect:', error);
                      return {
                        statusCode: 500,
                        headers: corsHeaders,
                        body: JSON.stringify({ error: 'Failed to initiate Shopify connection' })
                      };
                    }
                  } else if (path.includes('/shopify/callback')) {
                    // Handle OAuth callback
                    const queryParams = event.queryStringParameters || {};
                    const { code, state, shop } = queryParams;
                    
                    if (!code || !state || !shop) {
                      return {
                        statusCode: 400,
                        headers: { 'Content-Type': 'text/html' },
                        body: '<html><body><h2>Error: Missing required parameters</h2><script>setTimeout(() => window.close(), 3000);</script></body></html>'
                      };
                    }
                    
                    try {
                      // Verify state from DynamoDB
                      const stateResult = await dynamodb.get({
                        TableName: process.env.TABLE_NAME,
                        Key: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify'
                        }
                      }).promise();
                      
                      if (!stateResult.Item) {
                        throw new Error('Invalid state parameter');
                      }
                      
                      // Get Shopify credentials
                      const credentials = await getShopifyCredentials();
                      
                      // Exchange code for access token
                      const tokenData = querystring.stringify({
                        client_id: credentials.SHOPIFY_CLIENT_ID,
                        client_secret: credentials.SHOPIFY_CLIENT_SECRET,
                        code: code
                      });
                      
                      // Make HTTPS request to get access token
                      const accessToken = await new Promise((resolve, reject) => {
                        const options = {
                          hostname: shop,
                          path: '/admin/oauth/access_token',
                          method: 'POST',
                          headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Content-Length': Buffer.byteLength(tokenData)
                          }
                        };
                        
                        const req = https.request(options, (res) => {
                          let data = '';
                          res.on('data', (chunk) => { data += chunk; });
                          res.on('end', () => {
                            try {
                              const result = JSON.parse(data);
                              resolve(result.access_token);
                            } catch (e) {
                              reject(e);
                            }
                          });
                        });
                        
                        req.on('error', reject);
                        req.write(tokenData);
                        req.end();
                      });
                      
                      // Store the access token in DynamoDB
                      await dynamodb.put({
                        TableName: process.env.TABLE_NAME,
                        Item: {
                          pk: `store_${shop}`,
                          sk: `user_${stateResult.Item.userId}`,
                          accessToken: accessToken,
                          storeDomain: shop,
                          connectedAt: new Date().toISOString()
                        }
                      }).promise();
                      
                      // Delete the state token
                      await dynamodb.delete({
                        TableName: process.env.TABLE_NAME,
                        Key: {
                          pk: `oauth_state_${state}`,
                          sk: 'shopify'
                        }
                      }).promise();
                      
                      // Return success HTML that closes the popup
                      return {
                        statusCode: 200,
                        headers: { 'Content-Type': 'text/html' },
                        body: `<html><body>
                          <h2>✅ Successfully connected to Shopify!</h2>
                          <p>This window will close automatically...</p>
                          <script>
                            if (window.opener) {
                              window.opener.postMessage({ type: 'shopify-connected', success: true }, '*');
                            }
                            setTimeout(() => window.close(), 2000);
                          </script>
                        </body></html>`
                      };
                    } catch (error) {
                      console.error('Error in Shopify callback:', error);
                      return {
                        statusCode: 500,
                        headers: { 'Content-Type': 'text/html' },
                        body: `<html><body>
                          <h2>❌ Connection failed</h2>
                          <p>${error.message}</p>
                          <script>setTimeout(() => window.close(), 3000);</script>
                        </body></html>`
                      };
                    }
                  } else if (path.includes('/shopify/sync')) {
                    // Sync data using stored access token
                    const body = JSON.parse(event.body || '{}');
                    const { storeDomain, userId } = body;
                    
                    // Get access token from DynamoDB
                    const tokenResult = await dynamodb.get({
                      TableName: process.env.TABLE_NAME,
                      Key: {
                        pk: `store_${storeDomain}`,
                        sk: `user_${userId}`
                      }
                    }).promise();
                    
                    if (!tokenResult.Item || !tokenResult.Item.accessToken) {
                      return {
                        statusCode: 401,
                        headers: corsHeaders,
                        body: JSON.stringify({ error: 'Store not connected. Please connect first.' })
                      };
                    }
                    
                    // For now, return mock data
                    responseData = {
                      success: true,
                      message: 'Store data synced successfully',
                      data: {
                        storeId: 'store_' + Date.now(),
                        storeName: storeDomain.replace('.myshopify.com', ''),
                        syncedAt: new Date().toISOString(),
                        products: 10,
                        orders: 25,
                        customers: 15
                      }
                    };
                  } else {
                    responseData = {
                      message: 'Shopify integration endpoint',
                      endpoints: ['/api/shopify/connect', '/api/shopify/callback', '/api/shopify/sync']
                    };
                  }
                  break;
                  
                case 'auth':
                  // Handle authentication endpoints
                  const authPath = pathParts[2]; // e.g., login, register
                  const body = JSON.parse(event.body || '{}');
                  const cognito = new AWS.CognitoIdentityServiceProvider();
                  
                  if (authPath === 'login' && method === 'POST') {
                    try {
                      const { email, password } = body;
                      
                      if (!email || !password) {
                        return {
                          statusCode: 400,
                          headers: corsHeaders,
                          body: JSON.stringify({ success: false, error: 'Email and password required' })
                        };
                      }
                      
                      // Authenticate with Cognito
                      const authResult = await cognito.adminInitiateAuth({
                        UserPoolId: process.env.USER_POOL_ID,
                        ClientId: process.env.USER_POOL_CLIENT_ID,
                        AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',
                        AuthParameters: {
                          USERNAME: email,
                          PASSWORD: password
                        }
                      }).promise();
                      
                      responseData = {
                        success: true,
                        tokens: {
                          AccessToken: authResult.AuthenticationResult.AccessToken,
                          RefreshToken: authResult.AuthenticationResult.RefreshToken,
                          IdToken: authResult.AuthenticationResult.IdToken,
                          ExpiresIn: authResult.AuthenticationResult.ExpiresIn,
                          TokenType: authResult.AuthenticationResult.TokenType
                        }
                      };
                    } catch (error) {
                      console.error('Login error:', error);
                      return {
                        statusCode: 401,
                        headers: corsHeaders,
                        body: JSON.stringify({ 
                          success: false, 
                          error: error.code === 'NotAuthorizedException' ? 'Invalid credentials' : 'Login failed'
                        })
                      };
                    }
                  } else if (authPath === 'register' && method === 'POST') {
                    try {
                      const { email, password, companyName, firstName, lastName } = body;
                      
                      if (!email || !password || !companyName) {
                        return {
                          statusCode: 400,
                          headers: corsHeaders,
                          body: JSON.stringify({ 
                            success: false, 
                            error: 'Email, password and company name required' 
                          })
                        };
                      }
                      
                      // Generate unique company ID
                      const companyId = 'company-' + Date.now() + '-' + Math.random().toString(36).substring(7);
                      
                      // Create user in Cognito
                      const createUserResult = await cognito.adminCreateUser({
                        UserPoolId: process.env.USER_POOL_ID,
                        Username: email,
                        UserAttributes: [
                          { Name: 'email', Value: email },
                          { Name: 'email_verified', Value: 'true' },
                          { Name: 'custom:company_id', Value: companyId },
                          { Name: 'custom:company_name', Value: companyName },
                          { Name: 'custom:role', Value: 'admin' }
                        ],
                        TemporaryPassword: password,
                        MessageAction: 'SUPPRESS'
                      }).promise();
                      
                      // Set permanent password
                      await cognito.adminSetUserPassword({
                        UserPoolId: process.env.USER_POOL_ID,
                        Username: email,
                        Password: password,
                        Permanent: true
                      }).promise();
                      
                      // Store company info in DynamoDB
                      await dynamodb.put({
                        TableName: process.env.TABLE_NAME,
                        Item: {
                          pk: `company_${companyId}`,
                          sk: 'metadata',
                          companyName: companyName,
                          adminEmail: email,
                          createdAt: new Date().toISOString()
                        }
                      }).promise();
                      
                      responseData = {
                        success: true,
                        message: 'Registration successful',
                        userId: createUserResult.User.Username,
                        companyId: companyId,
                        companyName: companyName
                      };
                    } catch (error) {
                      console.error('Registration error:', error);
                      return {
                        statusCode: 400,
                        headers: corsHeaders,
                        body: JSON.stringify({ 
                          success: false, 
                          error: error.code === 'UsernameExistsException' ? 'User already exists' : 'Registration failed'
                        })
                      };
                    }
                  } else if (authPath === 'forgot-password' && method === 'POST') {
                    try {
                      const { email } = body;
                      
                      await cognito.forgotPassword({
                        ClientId: process.env.USER_POOL_CLIENT_ID,
                        Username: email
                      }).promise();
                      
                      responseData = {
                        success: true,
                        message: 'Password reset email sent'
                      };
                    } catch (error) {
                      console.error('Forgot password error:', error);
                      responseData = {
                        success: true, // Always return success to avoid user enumeration
                        message: 'If the email exists, a password reset link has been sent'
                      };
                    }
                  } else if (authPath === 'refresh' && method === 'POST') {
                    try {
                      const { refreshToken } = body;
                      
                      const authResult = await cognito.adminInitiateAuth({
                        UserPoolId: process.env.USER_POOL_ID,
                        ClientId: process.env.USER_POOL_CLIENT_ID,
                        AuthFlow: 'REFRESH_TOKEN_AUTH',
                        AuthParameters: {
                          REFRESH_TOKEN: refreshToken
                        }
                      }).promise();
                      
                      responseData = {
                        success: true,
                        tokens: {
                          AccessToken: authResult.AuthenticationResult.AccessToken,
                          IdToken: authResult.AuthenticationResult.IdToken,
                          ExpiresIn: authResult.AuthenticationResult.ExpiresIn,
                          TokenType: authResult.AuthenticationResult.TokenType
                        }
                      };
                    } catch (error) {
                      console.error('Refresh token error:', error);
                      return {
                        statusCode: 401,
                        headers: corsHeaders,
                        body: JSON.stringify({ success: false, error: 'Invalid refresh token' })
                      };
                    }
                  } else {
                    responseData = {
                      message: 'Authentication endpoint',
                      availableEndpoints: ['/api/auth/login', '/api/auth/register', '/api/auth/forgot-password', '/api/auth/refresh']
                    };
                  }
                  break;
                  
                default:
                  responseData = {
                    message: 'OrderNimbus API',
                    version: '1.0',
                    environment: process.env.ENVIRONMENT,
                    path: path,
                    method: method
                  };
              }
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify(responseData)
              };
              
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  # ==================== PAYMENT LAMBDA FUNCTION ====================
  PaymentLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: 'ordernimbus-production-payment'
      Runtime: nodejs16.x
      Handler: payment-handler.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          MAIN_TABLE_NAME: !Ref MainTable
          ENVIRONMENT: production
      Code:
        S3Bucket: !Ref LambdaCodeBucket
        S3Key: 'lambda/payment-handler.zip'

  # Payment Lambda Permission for API Gateway
  PaymentLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PaymentLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # Payment Lambda Integration
  PaymentLambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${PaymentLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  # Payment API Routes
  ApiPaymentSetupRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/payment/setup-intent'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  ApiPaymentMethodsGetRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/payment/methods'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  ApiPaymentMethodsPutRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'PUT /api/payment/methods'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  ApiPaymentMethodsDeleteRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'DELETE /api/payment/methods'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  ApiPaymentSubscriptionRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/payment/subscription'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  ApiPaymentWebhookRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/payment/webhook'
      Target: !Sub 'integrations/${PaymentLambdaIntegration}'

  # ==================== API GATEWAY (Simplified) ====================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: 'ordernimbus-production-api'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: 
          - 'http://app.ordernimbus.com'
          - 'https://app.ordernimbus.com'
          - 'http://localhost:3000'
          - 'http://127.0.0.1:3000'
          - !Sub 'http://${FrontendBucket}.s3-website-${AWS::Region}.amazonaws.com'
        AllowHeaders: 
          - '*'
        AllowMethods: 
          - GET
          - POST
          - PUT
          - DELETE
          - OPTIONS
          - HEAD
          - PATCH
        AllowCredentials: true
        ExposeHeaders:
          - '*'
        MaxAge: 86400

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: production
      AutoDeploy: true

  # Lambda Permission
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref MainLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # Single Integration
  LambdaIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${MainLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  # Catch-all route
  CatchAllRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: '$default'
      Target: !Sub 'integrations/${LambdaIntegration}'

  # Specific routes for clarity (optional but helps with API Gateway console)
  ApiProductsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/products'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiOrdersRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/orders'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiInventoryRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/inventory'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiCustomersRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/customers'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiNotificationsRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/notifications'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiStoresRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/stores'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiShopifyRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/shopify/{proxy+}'
      Target: !Sub 'integrations/${LambdaIntegration}'

  ApiAuthRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'ANY /api/auth/{proxy+}'
      Target: !Sub 'integrations/${LambdaIntegration}'

  # ==================== SSM PARAMETERS FOR CONFIGURATION ====================
  UserPoolIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /ordernimbus/production/cognito/user-pool-id
      Type: String
      Value: !Ref UserPool
      Description: Cognito User Pool ID for OrderNimbus
      
  UserPoolClientIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /ordernimbus/production/cognito/client-id
      Type: String
      Value: !Ref UserPoolClient
      Description: Cognito Client ID for OrderNimbus
      
  ApiEndpointParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /ordernimbus/production/api/endpoint
      Type: String
      Value: !Sub '${ApiGateway.ApiEndpoint}/production'
      Description: API Gateway endpoint for OrderNimbus
      
  FrontendDomainParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: /ordernimbus/production/frontend/cloudfront-domain
      Type: String
      Value: app.ordernimbus.com
      Description: CloudFront domain for OrderNimbus frontend

Outputs:
  FrontendURL:
    Description: Frontend URL (via CloudFront)
    Value: 'https://app.ordernimbus.com'
    Export:
      Name: !Sub '${AWS::StackName}-FrontendURL'

  CloudFrontDistributionId:
    Description: CloudFront Distribution ID
    Condition: CreateCloudFront
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDistributionId'

  CloudFrontDomainName:
    Description: CloudFront Distribution Domain Name
    Condition: CreateCloudFront
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub '${AWS::StackName}-CloudFrontDomainName'

  ApiEndpoint:
    Description: API Gateway endpoint
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/production'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  ApiDomainURL:
    Description: API Domain URL (if enabled)
    Value: 'https://api.ordernimbus.com'
    Export:
      Name: !Sub '${AWS::StackName}-ApiDomainURL'

  S3BucketName:
    Description: S3 Bucket for frontend hosting
    Value: !Ref FrontendBucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolId'

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolClientId'

  S3WebsiteURL:
    Description: S3 Website URL
    Value: !Sub 'http://${FrontendBucket}.s3-website-${AWS::Region}.amazonaws.com'
    Export:
      Name: !Sub '${AWS::StackName}-S3WebsiteURL'

  Region:
    Description: AWS Region
    Value: !Ref AWS::Region
    Export:
      Name: !Sub '${AWS::StackName}-Region'

  TableName:
    Description: Main DynamoDB Table
    Value: !Ref MainTable
    Export:
      Name: !Sub '${AWS::StackName}-TableName'

  DNSConfigured:
    Description: Whether DNS is configured
    Value: 'true'
    Export:
      Name: !Sub '${AWS::StackName}-DNSConfigured'

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolId'

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolClientId'