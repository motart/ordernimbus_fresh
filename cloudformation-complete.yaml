AWSTemplateFormatVersion: '2010-09-09'
Description: 'OrderNimbus - Complete Single-Stack Deployment'

Parameters:
  Environment:
    Type: String
    Default: staging
    AllowedValues: [dev, staging, production]
    Description: Environment name

Resources:
  # ==================== IAM ROLES ====================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                  - logs:*
                  - cognito-idp:*
                  - ses:SendEmail
                  - s3:*
                Resource: '*'

  # ==================== COGNITO ====================
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub 'ordernimbus-${Environment}-users'
      AutoVerifiedAttributes: [email]
      UsernameAttributes: [email]
      Schema:
        - Name: email
          Required: true
          Mutable: false
        - Name: name
          Required: false
          Mutable: true
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub 'ordernimbus-${Environment}-client'
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      PreventUserExistenceErrors: ENABLED

  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub 'ordernimbus-${Environment}-${AWS::AccountId}'
      UserPoolId: !Ref UserPool

  # ==================== DYNAMODB TABLES ====================
  StoresTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ordernimbus-${Environment}-stores'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: id
          KeyType: RANGE

  ProductsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ordernimbus-${Environment}-products'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: id
          KeyType: RANGE

  OrdersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ordernimbus-${Environment}-orders'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: id
          KeyType: RANGE

  SalesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ordernimbus-${Environment}-sales'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: id
          KeyType: RANGE

  OAuthStatesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'ordernimbus-${Environment}-oauth-states'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: state
          AttributeType: S
      KeySchema:
        - AttributeName: state
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

  # ==================== S3 BUCKETS ====================
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'ordernimbus-${Environment}-frontend-${AWS::AccountId}'
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'

  # ==================== LAMBDA FUNCTIONS ====================
  ProductsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-products-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const userId = event.headers?.userId || event.headers?.Userid || 'test-user-1';
              const storeId = event.queryStringParameters?.storeId || 'store-1';
              const productsTable = `${process.env.TABLE_PREFIX}-products`;
              
              const result = await dynamodb.scan({
                TableName: productsTable,
                FilterExpression: '#userId = :userId AND #storeId = :storeId',
                ExpressionAttributeNames: { '#userId': 'userId', '#storeId': 'storeId' },
                ExpressionAttributeValues: { ':userId': userId, ':storeId': storeId }
              }).promise();
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ products: result.Items || [], count: result.Items?.length || 0 })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  OrdersLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-orders-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const userId = event.headers?.userId || event.headers?.Userid || 'test-user-1';
              const storeId = event.queryStringParameters?.storeId || 'store-1';
              const ordersTable = `${process.env.TABLE_PREFIX}-orders`;
              
              const result = await dynamodb.scan({
                TableName: ordersTable,
                FilterExpression: '#userId = :userId AND #storeId = :storeId',
                ExpressionAttributeNames: { '#userId': 'userId', '#storeId': 'storeId' },
                ExpressionAttributeValues: { ':userId': userId, ':storeId': storeId }
              }).promise();
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ orders: result.Items || [], count: result.Items?.length || 0 })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  InventoryLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-inventory-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const userId = event.headers?.userId || event.headers?.Userid || 'test-user-1';
              const storeId = event.queryStringParameters?.storeId || 'store-1';
              
              // Return sample inventory data
              const inventory = [
                { id: '1', productId: 'prod-1', quantity: 100, location: 'Warehouse A' },
                { id: '2', productId: 'prod-2', quantity: 50, location: 'Warehouse B' }
              ];
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ inventory: inventory, count: inventory.length })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  CustomersLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-customers-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const userId = event.headers?.userId || event.headers?.Userid || 'test-user-1';
              const storeId = event.queryStringParameters?.storeId || 'store-1';
              
              // Return sample customer data
              const customers = [
                { id: '1', name: 'John Doe', email: 'john@example.com', totalOrders: 5 },
                { id: '2', name: 'Jane Smith', email: 'jane@example.com', totalOrders: 3 }
              ];
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ customers: customers, count: customers.length })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  NotificationsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-notifications-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const notifications = [
                { id: '1', type: 'info', message: 'System update completed', timestamp: new Date().toISOString() },
                { id: '2', type: 'warning', message: 'Low inventory alert', timestamp: new Date().toISOString() }
              ];
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ notifications: notifications, count: notifications.length })
              };
            } catch (error) {
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  StoresLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ordernimbus-${Environment}-stores-management'
      Runtime: nodejs18.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          TABLE_PREFIX: !Sub 'ordernimbus-${Environment}'
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1'
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          const dynamodb = new AWS.DynamoDB.DocumentClient();
          
          exports.handler = async (event) => {
            const corsHeaders = {
              'Access-Control-Allow-Origin': '*',
              'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,userId',
              'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
              'Content-Type': 'application/json'
            };
            
            if (event.httpMethod === 'OPTIONS' || event.requestContext?.http?.method === 'OPTIONS') {
              return { statusCode: 200, headers: corsHeaders, body: '' };
            }
            
            try {
              const userId = event.headers?.userId || event.headers?.Userid || 'test-user-1';
              const storesTable = `${process.env.TABLE_PREFIX}-stores`;
              
              const result = await dynamodb.query({
                TableName: storesTable,
                KeyConditionExpression: 'userId = :userId',
                ExpressionAttributeValues: { ':userId': userId }
              }).promise();
              
              return {
                statusCode: 200,
                headers: corsHeaders,
                body: JSON.stringify({ stores: result.Items || [] })
              };
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                headers: corsHeaders,
                body: JSON.stringify({ error: 'Internal server error' })
              };
            }
          };

  # ==================== API GATEWAY ====================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub 'ordernimbus-${Environment}-api'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins:
          - '*'
        AllowHeaders:
          - '*'
        AllowMethods:
          - GET
          - POST
          - PUT
          - DELETE
          - OPTIONS
        MaxAge: 86400

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: !Ref Environment
      AutoDeploy: true

  # Lambda Permissions for API Gateway
  ProductsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ProductsLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  OrdersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref OrdersLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  InventoryLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref InventoryLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  CustomersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CustomersLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  NotificationsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref NotificationsLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  StoresLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StoresLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*/*'

  # API Gateway Integrations
  ProductsIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${ProductsLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  OrdersIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${OrdersLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  InventoryIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${InventoryLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  CustomersIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${CustomersLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  NotificationsIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${NotificationsLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  StoresIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${StoresLambda}'
      IntegrationMethod: POST
      PayloadFormatVersion: '2.0'

  # API Routes
  ProductsRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/products'
      Target: !Sub 'integrations/${ProductsIntegration}'

  ProductsRoutePOST:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/products'
      Target: !Sub 'integrations/${ProductsIntegration}'

  ProductsRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/products'
      Target: !Sub 'integrations/${ProductsIntegration}'

  OrdersRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/orders'
      Target: !Sub 'integrations/${OrdersIntegration}'

  OrdersRoutePOST:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/orders'
      Target: !Sub 'integrations/${OrdersIntegration}'

  OrdersRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/orders'
      Target: !Sub 'integrations/${OrdersIntegration}'

  InventoryRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/inventory'
      Target: !Sub 'integrations/${InventoryIntegration}'

  InventoryRoutePOST:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/inventory'
      Target: !Sub 'integrations/${InventoryIntegration}'

  InventoryRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/inventory'
      Target: !Sub 'integrations/${InventoryIntegration}'

  CustomersRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/customers'
      Target: !Sub 'integrations/${CustomersIntegration}'

  CustomersRoutePOST:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/customers'
      Target: !Sub 'integrations/${CustomersIntegration}'

  CustomersRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/customers'
      Target: !Sub 'integrations/${CustomersIntegration}'

  NotificationsRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/notifications'
      Target: !Sub 'integrations/${NotificationsIntegration}'

  NotificationsRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/notifications'
      Target: !Sub 'integrations/${NotificationsIntegration}'

  StoresRouteGET:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'GET /api/stores'
      Target: !Sub 'integrations/${StoresIntegration}'

  StoresRoutePOST:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /api/stores'
      Target: !Sub 'integrations/${StoresIntegration}'

  StoresRouteOPTIONS:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'OPTIONS /api/stores'
      Target: !Sub 'integrations/${StoresIntegration}'

  # ==================== CLOUDFRONT ====================
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !Sub '${FrontendBucket}.s3-website-${AWS::Region}.amazonaws.com'
            CustomOriginConfig:
              OriginProtocolPolicy: http-only
        Enabled: true
        DefaultRootObject: index.html
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
          Compress: true
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
        PriceClass: PriceClass_100
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html

Outputs:
  FrontendURL:
    Description: Frontend CloudFront URL
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-FrontendURL'

  ApiEndpoint:
    Description: API Gateway endpoint
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolId'

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolClientId'

  S3BucketName:
    Description: S3 Bucket for frontend hosting
    Value: !Ref FrontendBucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  Region:
    Description: AWS Region
    Value: !Ref AWS::Region
    Export:
      Name: !Sub '${AWS::StackName}-Region'